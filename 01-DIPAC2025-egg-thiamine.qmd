---
title: "Chinook Egg Thiamine, Macaulay 2025"
author: "Drew Porter"
date-modified: today
format: html
fig-width: 7
fig-height: 5
fig-dpi: 300
lightbox: true
editor: source
  markdown: 
    wrap: 72
toc: true
toc-depth: 4
code-fold: true
output-file: "output"
editor_options: 
  chunk_output_type: console
---

## Introduction

This report is an analysis of Chinook salmon egg thiamine. Eggs were collected from returning Chinook salmon at DIPAC's Macaulay Hatchery in Juneau, AK on 2025-08-15.

For this analysis, individuals with eggs containing less than 5 nmol thiamine per gram are considered to be "thiamine deficient", this is the consensus literature value for deficient eggs. I am also interested in looking at thiamine on a per egg basis, I've classified individuals with less than 1 nmol thiamine per egg as deficient, this is not an established criteria.

### Glossary of Variables

`fish_id`

:   A unique identifier for each fish

`mid-eye-fork-length`

:   The length in millimeters for each fish, taken from the middle of the eye to the fork in the caudal fin.

`avg_egg_mass_g`

:   The average mass of an egg for each fish, measured in grams. Determined by dividing the total mass of eggs by the number of eggs measured for thiamine analysis.

`total_egg_mass_g`

:   The total mass of eggs, in grams, for each fish, measured at DIPAC after fertilization and water hardening.

`est_pre_hardened_egg_mass_g`

:   The estimated total mass of eggs, in grams, for each fish. Calculated by reducing the total egg mass by 23%, which is the estimated increase in salmon egg weight after water hardening, fertilization is not expected to significantly increase egg weight (Fleming and Ng, 1987). I was using this to estimate fecundity before Arthur sent estimated egg counts, I am using his counts now.

`est_fecund_n`

:   The total estimated fecundity, representing the total number of eggs produced by each female. Provided by Arthur Hamlett, DIPAC.

`nmolT_g`

:   Nanomoles of thiamine per gram of egg.

`nmolT_egg`

:   Nanomoles of thiamine per egg.

## Analysis

```{r}
#| label: setup
#| output: false

# Load libraries
library(tidyverse)
library(patchwork)
library(knitr)
library(ggpmisc)
library(here)
library(stringr) 
library(ggridges)
library(scales)
library(broom)
library(gt)
library(corrplot)
library(GGally)
library(corrr)
library(rstatix)
library(glue)
library(flexmix)
library(mclust)
library(factoextra)
library(lme4)
library(googlesheets4)


# ggplot theme set
theme_set(theme_bw())

# color palette
my_palette <- c("#1F77B4FF", "#FF7F0EFF", "#2CA02CFF", "#D62728FF", "#9467BDFF",
                "#8C564BFF", "#E377C2FF", "#7F7F7FFF", "#BCBD22FF", "#17BECFFF")

```

```{r}
#| label: load-data
#| output: false

dipac25 <- read_rds(here("data/processed/dipac_females.rds"))

dipac25_trim <- dipac25 |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, total_egg_mass_g,
         est_pre_hardened_egg_mass_g, est_fecund_n, nmolT_g, deficient_conc, 
         nmolT_egg, deficient_totalT) |> 
  mutate(
    drew_est_fecund = avg_egg_mass_g * est_pre_hardened_egg_mass_g,
    deficient_conc = factor(if_else(deficient_conc, "deficient", "replete", NA)),
    deficient_totalT = factor(if_else(deficient_totalT, "deficient", "replete", NA))
    )

# I want to check out nmol thiamine/egg but I don't have an established
# criteria for deficiency with this metric. I am going to take the bottom
# 25% of eggs and group them, and the top 75% and group them for exploration

nmol_egg_quant <- quantile(dipac25_trim$nmolT_egg)

dipac25_trim <- dipac25_trim |> 
  mutate(nmol_egg_status = factor(if_else(nmolT_egg > nmol_egg_quant[2][[1]],
                                   "top75", "bottom25", NA)))

# These fish tested positive for BKD and cannot be included in the study
bkd_fish <- c("f13", "f34")

dipac25_bkd_trim <- dipac25_trim |> 
  filter(!(fish_id %in% bkd_fish))

names(dipac25_trim)

```

### Histograms

```{r}
#| label: histogram-bin-widths

# Define a function for calculating histogram bin widths Freedman-Diaconis rule
# Bin Width = 2 * IQR / n^(1/3)

fg_bin_width <- function(IQR, n) {
  2 * IQR / n^(1/3)
}

# Calculate bin widths
bin_width_mefl <- fg_bin_width(IQR(dipac25_bkd_trim$`mid-eye-fork-length`), 
                                   length(dipac25_bkd_trim$`mid-eye-fork-length`))

bin_width_avg_egg_mass <- fg_bin_width(IQR(dipac25_bkd_trim$avg_egg_mass_g), 
                                   length(dipac25_bkd_trim$avg_egg_mass_g))

bin_width_est_fecund <- fg_bin_width(IQR(dipac25_bkd_trim$est_fecund_n), 
                                   length(dipac25_bkd_trim$est_fecund_n))

bin_width_nmolT_g <- fg_bin_width(IQR(dipac25_bkd_trim$nmolT_g), 
                                   length(dipac25_bkd_trim$nmolT_g))

bin_width_nmolT_egg <- fg_bin_width(IQR(dipac25_bkd_trim$nmolT_egg), 
                                   length(dipac25_bkd_trim$nmolT_egg))
```

```{r}
#| label: build-histograms

histo_mefl <- ggplot(data = dipac25_bkd_trim, aes(x = `mid-eye-fork-length`)) +
  geom_histogram(binwidth = bin_width_mefl, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_avg_egg_mass <- ggplot(data = dipac25_bkd_trim, aes(x = avg_egg_mass_g)) +
  geom_histogram(binwidth = bin_width_avg_egg_mass, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_est_fecund <- ggplot(data = dipac25_bkd_trim, aes(x = est_fecund_n)) +
  geom_histogram(binwidth = bin_width_est_fecund, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_nmolT_g <- ggplot(data = dipac25_bkd_trim, aes(x = nmolT_g)) +
  geom_histogram(binwidth = bin_width_nmolT_g, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_nmolT_egg <- ggplot(data = dipac25_bkd_trim, aes(x = nmolT_egg)) +
  geom_histogram(binwidth = bin_width_nmolT_egg, fill = "#2CA02CFF", color = "black") +
  geom_rug()
```

```{r}
#| label: plot-histograms
#| fig-cap: "Histograms for various fish and fish egg variables."

histo_patchwork <- histo_mefl + histo_avg_egg_mass + histo_est_fecund +
  histo_nmolT_g + histo_nmolT_egg + plot_layout(axes = "collect")

histo_patchwork
```

Everything is looking pretty normally distributed.

### Summary Statistics

```{r}
#| label: summary-stats-table

long_dipac25_bkd_trim <- dipac25_bkd_trim |>
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )

summary_table <- long_dipac25_bkd_trim |> 
  group_by(variable_name) |> 
  summarise(
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  )

summary_table |>
  kable(
    caption = "Summary Statistics for Fish and Egg Variables",
    col.names = c("Variable", "Mean", "Std. Dev.", "Min", "Max", "Median"),
    digits = 2
  )

```

### Exploring Egg Thiamine per Gram

#### Quartiles

```{r}
#| label: egg-thia-conc-quartiles

quantile(dipac25_bkd_trim$nmolT_g, probs = seq(0, 1, 0.25), na.rm = FALSE)

```

More than 25% of individuals eggs are deficient on a concentration basis.

#### % Deficient

```{r}

#| label: egg-thia-conc-count

dipac25_bkd_trim |> 
  summarise(
    n = n(),
    deficient = sum(deficient_conc == "deficient"),
    deficient_perc = (deficient / n) * 100
  )  |> 
  kable(
    caption = "Egg Thiamine Concentration",
    col.names = c("Individuals", "Number Deficient", "%Deficient"),
    digits = 2
  )

```

Of 58 fish, 16 are deficient (28%), what would it look like if we group the 16 lowest concentration fish for a deficient group, and the 16 highest concentration fish for a replete group?

## Grouping Ideas

### Lowest 16, Highest 16

In this grouping, we would select all the thiamine deficient (\<5 nmol T/g) fish for the low group, and the 16 fish with the highest egg thiamine concentrations for the high group.

#### Density Plots

```{r}
#| label: subset-low-high-group

bottom_16 <- dipac25_bkd_trim |> 
  arrange(desc(nmolT_g)) |> 
  slice_tail(n = 16)

top_16 <- dipac25_bkd_trim |> 
  arrange(desc(nmolT_g)) |> 
  slice_head(n = 16)

top_bottom_16 <- rbind(bottom_16, top_16) |> 
  mutate(group = factor(if_else(nmolT_g > 5.0, "replete", "deficient")))

```

```{r}
#| label: low-high-density-dist
#| message: false

density_low_high_mefl <- ggplot(top_bottom_16, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_avg_egg_mass <- ggplot(top_bottom_16, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_est_fecund <- ggplot(top_bottom_16, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_nmolT_g <- ggplot(top_bottom_16, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_nmolT_egg <- ggplot(top_bottom_16, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: low-high-combined-density-dist
#| message: false

patchwork_low_high_densities <- density_low_high_mefl +
  density_low_high_avg_egg_mass +
  density_low_high_est_fecund +
  density_low_high_nmolT_g +
  density_low_high_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_low_high_densities
```

#### Statistical Tests

```{r}
#| label: top-bot-16-parametric-tests
#| message: false

# T-test assumptions:
## 1.Independence of Observations --- Yes
## 2. Normality - shapiro.test()
## 3. Continuous data --- Yes
## 4. Random sampling --- Yes
## 5. Homogeneity of variance - var.test()

variables_to_test_parametric <- names(top_bottom_16[c(2,3,6,7,9)])

run_parametric_tests <- function(data, var_name) {
  
  
  var_res <- tidy(
    var.test(data[[var_name]] ~ data$group, data = data)
    )
  
  shapiro_replete_res <- tidy(
    shapiro.test(data[[var_name]][data$group == "replete"])
    )
  
  shapiro_deficient_res <- tidy(
    shapiro.test(data[[var_name]][data$group == "deficient"])
    )
  
  t_test_res <- tidy(
    t.test(data[[var_name]] ~ data$group, data = data, var.equal = TRUE)
  )
  
  tibble(
    Variable = var_name,
    `Shapiro p (replete)` = shapiro_replete_res$p.value,
    `Shapiro p (deficient)` = shapiro_deficient_res$p.value,
    `Var test p` = var_res$p.value,
    `t-statistic` = case_when(
      `Shapiro p (replete)` < 0.05 |
        `Shapiro p (deficient)` < 0.05 |
        `Var test p` < 0.05 ~ NA,
      TRUE ~ t_test_res$statistic
    ),
    `t-test p` = case_when(
      `Shapiro p (replete)` < 0.05 |
        `Shapiro p (deficient)` < 0.05 |
        `Var test p` < 0.05 ~ NA,
      TRUE ~ t_test_res$p.value
      )    
    )  
  
}

parametric_list_results <- purrr::map(
  variables_to_test_parametric, ~run_parametric_tests(top_bottom_16, .x)
  ) 
parametric_test_results <- list_rbind(parametric_list_results)

parametric_table <- parametric_test_results |> 
  gt() |> 
  tab_header(
    title = "Parametric Statistical Tests",
    subtitle = "Top/Bottom 16 Fish"
  ) |> 
  tab_spanner(
    label = md("Shapiro-Wilk Normality Test"),
    columns = c(`Shapiro p (replete)`, `Shapiro p (deficient)`)
  ) |> 
  tab_spanner(
    label = "F Test",
    columns = `Var test p`
  ) |> 
  tab_spanner(
    label = "Student's t-Test",
    columns = c(`t-statistic`, `t-test p`)
  ) |> 
  cols_label(
    `Shapiro p (replete)` = md("*p*~replete~"),
    `Shapiro p (deficient)` = md("*p*~deficient~"),
    `Var test p`= md("*p*"),
    `t-test p` = md("*p*")
  ) |> 
  tab_style(
    style = list(
      cell_text(color = "red")
    ),
    locations = list(
      cells_body(
      columns = `Shapiro p (replete)`,
      rows = `Shapiro p (replete)` < 0.05 
    ),
    cells_body(
      columns = `Shapiro p (deficient)`,
      rows = `Shapiro p (deficient)` < 0.05 
    ),
    cells_body(
      columns = `Var test p`,
      rows = `Var test p` < 0.05 
    )
    )
  ) |>
  fmt_number(
    columns = everything(),
    decimals = 3
  ) |> 
  sub_values(
    columns = contains("p"),
    fn = \(x) x < .001, replacement = "<0.001"
  )
  
parametric_table

```

Between the two groups, mid-eye-fork-length, average egg mass (g), and estimated fecundity are not statistically different. Egg thiamine concentration and total egg thiamine violate normality and/or homogeneity of variance assumptions and will be tested with a non-parametric alternative.

```{r}
#| label: top-bot-16-non-parametric-tests
#| message: false

 # Mann-Whitney U Test Assumptions:
 # 1. All the observations from both groups are independent of each other,
 # 2. The responses are at least ordinal (i.e., one can at least say, of any two
 #    observations, which is the greater),
 # 3. Under the null hypothesis H0, the distributions of both populations are
 #    identical.
 # 4. The alternative hypothesis H1 is that the distributions are not identical.

variables_to_test_non_parametric <- names(top_bottom_16[c(7,9)])

run_non_parametric_tests <- function(data, var_name) {
  
  wilcox_res <- tidy(
    wilcox.test(data[[var_name]] ~ data$group, data = data)
    )
  
  tibble(
    Variable = var_name,
    `Mann-Whitney U p` = wilcox_res$p.value,
    `W statistic` = wilcox_res$statistic
    )  
  
}

non_parametric_list_results <- purrr::map(
  variables_to_test_non_parametric, ~run_non_parametric_tests(top_bottom_16, .x)
  ) 
non_parametric_test_results <- list_rbind(non_parametric_list_results)

non_parametric_table <- non_parametric_test_results |> 
  gt() |> 
  tab_header(
    title = "Non-Parametric Statistical Tests",
    subtitle = "Top/Bottom 16 Fish"
  ) |> 
  tab_spanner(
    label = md("Mann-Whitney U"),
    columns = c(`Mann-Whitney U p`, `W statistic`)
  ) |> 
  cols_label(
    `Mann-Whitney U p` = md("*p*"),
    `W statistic` = "W"
  ) |> 
    fmt_number(
    columns = everything(),
    decimals = 1
  ) |> 
  sub_values(
    columns = `Mann-Whitney U p`,
    fn = \(x) x < .001, replacement = "<0.001"
  )

non_parametric_table

```

Egg thiamine concentration and total egg thiamine are statistically significantly different between the low and high groups.

#### Summary Stats

```{r}
#| label: low-high-summary-stats
#| message: false

long_top_bottom_16 <- top_bottom_16 |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
    pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )

low_high_summary_table <- long_top_bottom_16 |> 
  group_by(variable_name, group) |> 
  summarise(
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for Lowest/Highest 16 Egg T. Concs",
    col.names = c("Variable", "Group" ," Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

low_high_summary_table

```

```{r}
#| label: low-high-gamete-est
#| output: false

deficient_gametes_top_bot_16 <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

replete_gametes_top_bot_16 <- top_bottom_16 |> 
  filter(group == "replete") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females
bot_16_females <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  pull(fish_id)

formatted_deficient_id_list <- combine_words(bot_16_females)

# Get replete females
top_16_females <- top_bottom_16 |> 
  filter(group == "replete") |> 
  pull(fish_id)

formatted_replete_id_list <- combine_words(top_16_females)

# Calculate fish in each group and proportional gametes
top_bottom_16_total_n <- length(top_bottom_16$fish_id)

top_bot_16_deficient_n <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  nrow()

top_bot_16_replete_n <- top_bottom_16_total_n - top_bot_16_deficient_n 

# Gametes
## Even Split

top_bot_16_even_split_gametes <- 90000 / 2 

top_bot_16_even_split_gametes_per_fish_deficient <-
  round(top_bot_16_even_split_gametes / top_bot_16_deficient_n, 0)

top_bot_16_even_split_gametes_per_fish_replete <-
  round(top_bot_16_even_split_gametes / top_bot_16_replete_n, 0)

### Is it even possible to get that many gametes from the deficient group?
top_bot_16_even_split_gametes_per_fish_deficient <= bottom_16$est_fecund_n

# 1 fish comes up short, which fish?
top_bot_16_short_deficient_fish <- bottom_16 |> 
  filter(top_bot_16_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_top_bot_16_short_deficient_fish  <- combine_words(
  top_bot_16_short_deficient_fish$fish_id)

fmt_top_bot_16_short_deficient_fish_gametes <- combine_words(comma(round(
  top_bot_16_short_deficient_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
top_bot_16_even_split_gametes_per_fish_replete <= top_16$est_fecund_n

# 1 fish comes up short, which fish?
top_bot_16_short_replete_fish <- top_16 |> 
  filter(top_bot_16_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_top_bot_16_short_replete_fish  <- combine_words(
  top_bot_16_short_replete_fish$fish_id)

fmt_top_bot_16_short_replete_fish_gametes <- combine_words(comma(round(
  top_bot_16_short_replete_fish$est_fecund_n, 0)))
```

This group would contain `{r} top_bot_16_deficient_n` fish in the deficient group and `{r} top_bot_16_replete_n` fish in the replete group. If gametes were split evenly per group and per fish that would be `{r} comma(90000/2)` gametes per group and `{r} comma(top_bot_16_even_split_gametes_per_fish_deficient)` gametes per fish.

Of the deficient fish, `{r} fmt_top_bot_16_short_deficient_fish` comes up short with `{r} fmt_top_bot_16_short_deficient_fish_gametes` estimated gametes.

Of the replete fish, `{r} fmt_top_bot_16_short_replete_fish` comes up short with `{r} fmt_top_bot_16_short_replete_fish_gametes` estimated gametes.

The deficient females for this grouping are `{r} formatted_deficient_id_list`.

The replete females for this grouping are `{r} formatted_replete_id_list`.

### 50/50 split

In this grouping, we would keep all `{r} length(dipac25_bkd_trim$fish_id)` fish in the study and divide the low and high groups down the middle of egg thiamine concentrations (`{r} round(median(dipac25_bkd_trim$nmolT_g), 2)` nmol T/g).

#### Density Plots

```{r}
#| label: fifty-fifty-grouping

fifty_fifty <- dipac25_bkd_trim |> 
  mutate(group = factor(if_else(nmolT_g >= median(nmolT_g), "high", "low"),
                        levels = c("low", "high")))
```

```{r}
#| label: fifty-fifty-density-dist
#| message: false

density_fifty_fifty_mefl <- ggplot(fifty_fifty, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_avg_egg_mass <- ggplot(fifty_fifty, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_est_fecund <- ggplot(fifty_fifty, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_nmolT_g <- ggplot(fifty_fifty, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_nmolT_egg <- ggplot(fifty_fifty, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: fifty-fifty-combined-density-dist
#| message: false

patchwork_fifty_fifty_densities <- density_fifty_fifty_mefl +
  density_fifty_fifty_avg_egg_mass +
  density_fifty_fifty_est_fecund +
  density_fifty_fifty_nmolT_g +
  density_fifty_fifty_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_fifty_fifty_densities
```

#### Summary Stats

```{r}
#| label: fifty-fifty-summary-stats
#| message: false

fifty_fifty_long <- fifty_fifty |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )    
  
fifty_fifty_summary_table <- fifty_fifty_long |> 
  group_by(variable_name, group) |> 
  summarise(
    n = n(),
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for 50/50 Split Grouping",
    col.names = c("Variable", "Group", "N", " Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

fifty_fifty_summary_table

```

```{r}
#| label: fifty-fifty-gamete-est
#| output: false

total_gametes_fifty_fifty <- scales::comma(sum(fifty_fifty$est_fecund_n))

fifty_fifty_low <- fifty_fifty |> 
  filter(group == "low")

fifty_fifty_low_deficient_gametes <- fifty_fifty |> 
  filter(group == "low" & deficient_conc == "deficient") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

fifty_fifty_low_replete_gametes <- fifty_fifty |> 
  filter(group == "low" & deficient_conc == "replete") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

fifty_fifty_high_replete_gametes <- fifty_fifty |> 
  filter(group == "high" & deficient_conc == "replete") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females low group
fifty_fifty_low_deficient <- fifty_fifty |> 
  filter(group == "low" & deficient_conc == "deficient")

fifty_fifty_low_deficient_females <- fifty_fifty_low_deficient |> 
  pull(fish_id)

fmt_fifty_fifty_low_deficient_ids <- combine_words(fifty_fifty_low_deficient_females)

# Get replete females low group
fifty_fifty_low_replete <- fifty_fifty |> 
  filter(group == "low" & deficient_conc == "replete")

fifty_fifty_low_replete_females <- fifty_fifty_low_replete |> 
  pull(fish_id)

fmt_fifty_fifty_low_replete_ids <- combine_words(fifty_fifty_low_replete_females)

# Get replete females high group


fifty_fifty_high_replete <- fifty_fifty |> 
  filter(group == "high" & deficient_conc == "replete") 

fifty_fifty_high_replete_females <- fifty_fifty_high_replete |> 
  pull(fish_id)

fmt_fifty_fifty_high_replete_ids <- combine_words(fifty_fifty_high_replete_females)

# Calculate fish in each group and proportional gametes
fifty_fifty_total_n <- length(fifty_fifty$fish_id)

fifty_fifty_low_n <- fifty_fifty |> 
  filter(group == "low") |> 
  nrow()

fifty_fifty_high_n <- fifty_fifty_total_n - fifty_fifty_low_n

# Gametes
## Even Split

fifty_fifty_even_split_gametes <- 90000 / 2 

fifty_fifty_even_split_gametes_per_fish_low <-
  round(fifty_fifty_even_split_gametes / fifty_fifty_low_n, 0)

fifty_fifty_even_split_gametes_per_fish_high <- 
  round(fifty_fifty_even_split_gametes / fifty_fifty_high_n, 0)

### Is it even possible to get that many gametes from the deficient group?
fifty_fifty_even_split_gametes_per_fish_low <= fifty_fifty_low$est_fecund_n

# 1 fish comes up short, which fish?
fifty_fifty_short_low_fish <- fifty_fifty_low |> 
  filter(fifty_fifty_even_split_gametes_per_fish_low > est_fecund_n)

fmt_fifty_fifty_short_low_fish <- combine_words(
  fifty_fifty_short_low_fish$fish_id)

fmt_fifty_fifty_short_low_fish_gametes <- combine_words(comma(round(
  fifty_fifty_short_low_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
fifty_fifty_even_split_gametes_per_fish_high <= fifty_fifty_high_replete$est_fecund_n

# All replete fish have enough gametes
```

This grouping would contain `{r} fifty_fifty_low_n` fish in the "low" group; of those fish `{r} length(fifty_fifty_low_deficient_females)` would be considered "deficient" in egg thiamine concentration, `{r} length(fifty_fifty_low_replete_females)` would be considered "replete". The "high" group would contain `{r} fifty_fifty_high_n` "replete" fish.

Our 90,000 fish allowance would include `{r} comma(90000/2)` "low" and `{r} comma(90000/2)` "high" gametes if we split the groups evenly, this works out to `{r} comma(90000 / length(fifty_fifty$fish_id))` gametes per fish.

Of the low group, fish `{r} fmt_fifty_fifty_short_low_fish` does not have enough estimated gametes (`{r} fmt_fifty_fifty_short_low_fish_gametes`). All of the high group fish have enough estimated gametes.

The deficient females in the "low" group for this grouping are `{r} fmt_fifty_fifty_low_deficient_ids`. The replete females in the "low" group for this grouping are `{r} fmt_fifty_fifty_low_replete_ids`.

The replete females in the "high" group for this grouping are `{r} fmt_fifty_fifty_high_replete_ids`.

### 5 nmol T/g split

In this grouping, we would keep all `{r} length(dipac25_bkd_trim$fish_id)` fish in the study and divide the deficient and replete groups at the 5 nmol T/g benchmark. This would result in an uneven split.

#### Density Plots

```{r}
#| label: five-nmol-grouping

five_nmol <- dipac25_bkd_trim |> 
  mutate(group = factor(if_else(nmolT_g >= 5, "replete", "deficient"),
                        levels = c("deficient", "replete")))
```

```{r}
#| label: five-nmol-density-dist
#| message: false

density_five_nmol_mefl <- ggplot(five_nmol, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_avg_egg_mass <- ggplot(five_nmol, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_est_fecund <- ggplot(five_nmol, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_nmolT_g <- ggplot(five_nmol, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_nmolT_egg <- ggplot(five_nmol, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: five-nmol-combined-density-dist
#| message: false

patchwork_five_nmol_densities <- density_five_nmol_mefl +
  density_five_nmol_avg_egg_mass +
  density_five_nmol_est_fecund +
  density_five_nmol_nmolT_g +
  density_five_nmol_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_five_nmol_densities
```

#### Summary Stats

```{r}
#| label: five-nmol-summary-stats
#| message: false

five_nmol_long <- five_nmol |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )    
  
five_nmol_summary_table <- five_nmol_long |> 
  group_by(variable_name, group) |> 
  summarise(
    n = n(),
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for 5 nmol T/g Split Grouping",
    col.names = c("Variable", "Group", "N", " Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

five_nmol_summary_table

```

```{r}
#| label: five-nmol-gamete-est
#| output: false
#| message: false

total_gametes_five_nmol <- round(sum(five_nmol$est_fecund_n), 0)

five_nmol_deficient_gametes <- five_nmol |> 
  filter(group == "deficient") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

five_nmol_replete_gametes <- five_nmol |> 
  filter(group == "replete") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females 
five_nmol_deficient <- five_nmol |> 
  filter(group == "deficient")

five_nmol_deficient_females <- five_nmol_deficient |> 
  pull(fish_id)

fmt_five_nmol_deficient_ids <- combine_words(five_nmol_deficient_females)

# Get replete females group
five_nmol_replete <- five_nmol |> 
  filter(group == "replete") 

five_nmol_replete_females <- five_nmol_replete |> 
  pull(fish_id)

fmt_five_nmol_replete_ids <- combine_words(five_nmol_replete_females)

# Calculate fish in each group and proportional gametes
five_nmol_total_n <- length(five_nmol$fish_id)

five_nmol_deficient_n <- length(five_nmol_deficient$fish_id)

five_nmol_replete_n <- length(five_nmol_replete$fish_id)

five_nmol_deficient_prop <- five_nmol_deficient_n / five_nmol_total_n

five_nmol_replete_prop <- five_nmol_replete_n / five_nmol_total_n

# Gametes
## Even Split

five_nmol_even_split_gametes <- 90000 / 2 

five_nmol_even_split_gametes_per_fish_deficient <-
  round(five_nmol_even_split_gametes / five_nmol_deficient_n, 0)

five_nmol_even_split_gametes_per_fish_replete <- 
  round(five_nmol_even_split_gametes / five_nmol_replete_n, 0)

### Is it even possible to get that many gametes from the deficient group?
five_nmol_even_split_gametes_per_fish_deficient <= five_nmol_deficient$est_fecund_n

# 1 fish comes up short, which fish?
five_nmol_short_deficient_fish <- five_nmol_deficient |> 
  filter(five_nmol_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_five_nmol_short_deficient_fish <- combine_words(
  five_nmol_short_deficient_fish$fish_id)

fmt_five_nmol_short_deficient_fish_gametes <- combine_words(comma(round(
  five_nmol_short_deficient_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
five_nmol_even_split_gametes_per_fish_replete <= five_nmol_replete$est_fecund_n

## Proportional split

five_nmol_prop_split_gametes_deficient <- 
  round(five_nmol_deficient_prop * 90000, 0) 

five_nmol_prop_split_gametes_per_fish_deficient <- 
  round(five_nmol_prop_split_gametes_deficient / five_nmol_deficient_n, 0) 

five_nmol_prop_split_gametes_replete <- 
  round(five_nmol_replete_prop * 90000, 0) 

five_nmol_prop_split_gametes_per_fish_replete <- 
  round(five_nmol_prop_split_gametes_replete / five_nmol_replete_n, 0) 

# Is this possible for deficient fish?

five_nmol_prop_split_gametes_per_fish_deficient <= five_nmol_deficient$est_fecund_n

# 1 fish come up short, which fish?
five_nmol_short_prop_deficient_fish <- five_nmol_deficient |> 
  filter(five_nmol_prop_split_gametes_per_fish_deficient > est_fecund_n)

fmt_five_nmol_short_prop_deficient_fish <- combine_words(
  five_nmol_short_prop_deficient_fish$fish_id)

fmt_five_nmol_short_prop_deficient_fish_gametes <- combine_words(comma(round(
  five_nmol_short_prop_deficient_fish$est_fecund_n, 0)))

# Possible for replete group? 
five_nmol_prop_split_gametes_per_fish_replete <= 
  five_nmol_replete$est_fecund_n

# All replete fish have enough gametes
```

This grouping would contain `{r} five_nmol_deficient_n` fish in the "deficient" group and `{r} five_nmol_replete_n` fish in the "replete" group. Proportionately that is `{r} round(five_nmol_deficient_prop * 100, 1)`% deficient fish and `{r} round(five_nmol_replete_prop * 100, 1)`% replete fish.

If we wanted to have an even number of gametes per group (i.e., `{r} comma(90000/2)` gametes), it would require `{r} comma(five_nmol_even_split_gametes_per_fish_deficient)` gametes per deficient fish and `{r} comma(five_nmol_even_split_gametes_per_fish_replete)` gametes per replete fish. One deficient fish (`{r} fmt_five_nmol_short_deficient_fish`) is short of this many estimated gametes (`{r} fmt_five_nmol_short_deficient_fish_gametes`). This shortage could be covered by other deficient fish. All of the replete fish have enough gametes for this split.

If we wanted to have a proportional number of gametes for each group (i.e., `{r} comma(five_nmol_prop_split_gametes_deficient)` gametes for the deficient group and `{r} comma(five_nmol_prop_split_gametes_replete)` gametes for the replete group), it would require `{r} comma(five_nmol_prop_split_gametes_per_fish_deficient)` per fish for each group. Again, fish `{r} fmt_five_nmol_short_prop_deficient_fish` from the deficient group comes up short (only `{r} fmt_five_nmol_short_prop_deficient_fish_gametes` estimated gametes). This shortage could be covered by other deficient females. For the replete group, all fish have enough estimated gametes.

The deficient females in this grouping are: `{r} fmt_five_nmol_deficient_ids`.

The replete females in this grouping are: `{r} fmt_five_nmol_replete_ids`.

## Andrew Creek Stock Thiamine Concentrations

![Andrew Creek stock Chinook salmon thiamine concentrations. The dashed red line indicates 5 nmol T/g, the threshold for deficient eggs.](output/plots/andrew_creek_thiamine_conc_yearly.png) Looks to be a decreasing trend over the years, though sample size is limited before 2024.

## Correlation Matrix

```{r}
#| label: correlation-matrix

dipac25_trim_numeric <- dipac25_trim |> 
  select(
    `mid-eye-fork-length`,
    avg_egg_mass_g,
    est_fecund_n,
    nmolT_g,
    nmolT_egg,
    deficient_conc
  )

# Correlation alpha
cor_alpha <- 0.05

# Overall correlation matrix
dipac25_overall_cors <- dipac25_trim_numeric |> 
  select(-deficient_conc) |> 
  cor_mat() |> 
  cor_gather() |> 
  mutate(group = "overall")

# Correlation matrix for replete group

dipac25_replete_cors <- dipac25_trim_numeric |> 
  filter(deficient_conc == "replete") |> 
  select(-deficient_conc) |> 
  cor_mat() |> 
  cor_gather() |>
  mutate(group = "replete")

# Correlation matrix for deficient group

dipac25_deficient_cors <- dipac25_trim_numeric |> 
  filter(deficient_conc == "deficient") |> 
  select(-deficient_conc) |> 
  cor_mat() |> 
  cor_gather() |>
  mutate(group= "deficient")
  
# Combine all corr tables

main_cors <- bind_rows(
  dipac25_overall_cors, 
  dipac25_replete_cors, 
  dipac25_deficient_cors
  ) |> 
  # remove duplicate pairs (A vs B is same as B vs A)
  rowwise() |> 
  mutate(pair_id = paste(sort(c(var1, var2)), collapse = "_")) |> 
  ungroup() |> 
  distinct(pair_id, group, .keep_all = TRUE) |> 
  pivot_wider(
    id_cols = c(var1, var2),
    names_from = group,
    values_from = c(cor, p)
  ) |> 
  filter(!(cor_overall == 1 & cor_replete == 1 & cor_deficient == 1)) |> 
  filter(p_overall < cor_alpha | p_replete < cor_alpha | p_deficient < cor_alpha)

# Correlation plot

ggpairs(dipac25_trim,
        columns = c(2,3,6,7,9),
        aes(color = deficient_conc,
            fill = deficient_conc,
            alpha = 0.5)) +
  scale_color_discrete(type = my_palette) +
  scale_fill_discrete(type = my_palette)


```

```{r}
#| label: correlation-results
#| results: asis
#| echo: false


p_formatter <- label_pvalue(accuracy = .001, add_p = TRUE)

cat("Correlations of interest were found between:\n")

pwalk(main_cors, function(var1, var2, 
                          cor_overall, p_overall,
                          cor_replete, p_replete,
                          cor_deficient, p_deficient) {
  
  cat(glue("\n\n* **{var1}** and **{var2}**"))
  
  if (!is.na(p_overall) && p_overall < cor_alpha) {
    cat(glue(
      "\n\n    + Overall *r* = {round(cor_overall, 2)},
      {p_formatter(p_overall)}",
      .trim = FALSE
    ))
  } else {
    cat(glue(
      "\n\n    + Overall correlation was not significant.",
      .trim = FALSE
    ))
  }
  
  if (!is.na(p_replete) && p_replete < cor_alpha) {
    cat(glue(
      "\n\n    + Replete group *r* = {round(cor_replete, 2)},
      {p_formatter(p_replete)}",
      .trim = FALSE
      ))
  } else {
    cat("\n\n    + Not significant for the replete group.")
  }
  

  if (!is.na(p_deficient) && p_deficient < cor_alpha) {
    cat(glue(
      "\n\n    + Deficient group *r* = {round(cor_deficient, 2)},
      {p_formatter(p_deficient)}",
      .trim = FALSE
      ))
  } else {
    cat("\n\n    + Not significant for the deficient group.")
  }
})

```

## Linear Models

Investigating linear regression of different variables.

### Fecundity as a function of egg thiamine concentration

```{r}
#| label: est-fecund-vs-conc
#| fig-cap: "There was no significant linear correlation found between egg thiamine (nmol/g) and estimated fecundity."

ggplot(data = dipac25, aes(x = nmolT_g, y = est_fecund_n)) +
  geom_point() +
  stat_poly_eq(use_label(c("eq", "r2", "p")))


```

### Fecundity as a function of mid-eye-fork-length

```{r}
#| label: est-fecund-vs-mefl
#| fig-cap: "There was a significant linear correlation found between egg thiamine (nmol/g) and estimated fecundity."

ggplot(data = dipac25_trim, aes(x = `mid-eye-fork-length`, y = est_fecund_n)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE,
               coef.digits = 5)


```

### Total egg thiamine (nmol/egg) as a function of mid-eye-fork-length

```{r}
#| label: nmolTegg-vs-mefl-overall
#| fig-cap: "There was no significant overall linear correlation found between total egg thiamine (nmol/egg) and mid-eye-fork-length, but it's pretty close."

ggplot(data = dipac25_trim, aes(x = `mid-eye-fork-length`, y = nmolT_egg,
                                color = deficient_conc)) +
  geom_point() +
  #stat_poly_line(color = "black") +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE,
               coef.digits = 3,
               color = "black") + 
  guides(color = "none") +
  scale_color_discrete(type = my_palette)

```

```{r}
#| label: nmolTegg-vs-mefl-grouped
#| fig-cap: "However, when grouped by thiamine status (deficient or replete; determined by egg concentration), there is a significant linear correlation found between total egg thiamine (nmol/egg) and mid-eye-fork-length."

ggplot(data = dipac25_trim, aes(x = `mid-eye-fork-length`, y = nmolT_egg,
                                color = deficient_conc)) +
  geom_point(size = 2) +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "r2", "p"),
               small.p = TRUE,
               coef.digits = 3) +
  #geom_text(aes(label = fish_id), vjust = "top", hjust = "right") +
  scale_color_discrete(type = my_palette) +
  theme(
    legend.position = "bottom"
  )

```

Here I am trying out a purely theoretical egg status grouping. Taking the bottom 25% and the top 75% of nmol thiamine/egg values and grouping them.

```{r}
#| label: nmolTegg-vs-mefl-trial-group
#| fig-cap: "Theoretical grouping by total egg thiamine (top 75% vs. bottom 25%). There are still significant linear correlations found between total egg thiamine (nmol/egg) and mid-eye-fork-length, but they are slightly weaker than with the established 5 nmol T/g grouping."

ggplot(data = dipac25_trim, aes(x = `mid-eye-fork-length`, y = nmolT_egg,
                                color = nmol_egg_status)) +
  geom_point(size = 2) +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "r2", "p"),
               small.p = TRUE,
               coef.digits = 3) +
  #geom_text(aes(label = fish_id), vjust = "top", hjust = "right") +
  scale_color_discrete(type = my_palette) +
  theme(
    legend.position = "bottom"
  )

```

With this theoretical grouping the fits are worse than just using the 5 nmol T/g grouping.

## Egg Thiamine Concentration vs. Content Exploration

-   Egg thiamine content ($T$), or the total amount of thiamine in an egg (nmol)
-   Egg thiamine concentration ($C$), or the total amount of thiamine per unit of mass (nmol/g)
-   Average egg mass ($M$), the weight of an egg (g)

These variables are directly related:

$$T = C \times M $$ or:

$$ C = \frac{T}{M} $$

So when we model total egg thiamine as a function of egg thiamine concentration without accounting for mass, the relationship looks noisy if there is any variation in egg mass:

```{r}
#| label: content-concentration-overall

ggplot(dipac25_trim, aes(x = nmolT_g, y = nmolT_egg)) +
  geom_point(alpha = 0.7) +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE) +
  stat_poly_line(se = FALSE) +
  labs(
    x = "Egg Thiamine Concentration (nmol/g)",
    y = "Total Egg Thiamine (nmol)"
  ) +
  scale_color_discrete(type = my_palette) +
  scale_x_continuous(limits = c(0, 12), 
                     breaks = seq(0, 12, 2),
                     expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 4),
                     breaks = seq(0, 4, 1),
                     expand = c(0, 0))

```

It's a good fit, but it should be a perfect fit because total egg thiamine is calculated **using** egg thiamine concentration. It's not a perfect fit because we have not accounted for mass. We can explore this futher by breaking the eggs out into quantiles by their egg masses, when there is less variation in egg mass, the fit improves:

```{r}
#| label: content-concentration-quartiles

# Break eggs into size classes based on quartiles
dipac25_size_class <- dipac25_trim |> 
  mutate(
    mass_quartile = factor(ntile(avg_egg_mass_g, 4),
                           labels = c("Q1", "Q2", "Q3", "Q4"))
  )

ggplot(dipac25_size_class, aes(x = nmolT_g, y = nmolT_egg, color = mass_quartile)) +
  geom_point(alpha = 0.7) +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE) +
  stat_poly_line(se = FALSE) +
  labs(
    x = "Egg Thiamine Concentration (nmol/g)",
    y = "Total Egg Thiamine (nmol)",
    color = "Mass Quartile"
  ) +
  scale_color_discrete(type = my_palette) +
  scale_x_continuous(limits = c(0, 12), 
                     breaks = seq(0, 12, 2),
                     expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 4),
                     breaks = seq(0, 4, 1),
                     expand = c(0, 0))

# The ':' tells R to only use the interaction term between the two variables
formal_model <- lm(nmolT_egg ~ nmolT_g:avg_egg_mass_g, data = dipac25_trim)
summary(formal_model)

```

Each fit is better than the overall fit, but still not perfect. We've decreased the variation in egg mass by grouping similarly sized eggs together, but we haven't accounted for egg mass in the model itself.

What we've been fitting:

$$ 
T \sim C 
$$ What we need to fit:

$$
T \sim C \times M
$$ When we do this, we get the perfect fit we expect:

```{r}
#| label: content-concentration-overall-interaction

dipac25_trim$interaction <- dipac25_trim$avg_egg_mass_g * dipac25_trim$nmolT_g

ggplot(dipac25_trim, aes(x = interaction, y = nmolT_egg)) +
  geom_point(alpha = 0.7) +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE) +
  stat_poly_line(se = FALSE) +
  labs(
    x = "Egg Thiamine Concentration (nmol/g) x Average Egg Mass (g)",
    y = "Total Egg Thiamine (nmol)"
  ) +
  scale_color_discrete(type = my_palette)
  #scale_x_continuous(limits = c(0, 12), 
  #                   breaks = seq(0, 12, 2),
  #                   expand = c(0, 0)) +
  #scale_y_continuous(limits = c(0, 4),
  #                   breaks = seq(0, 4, 1),
  #                   expand = c(0, 0))

```

```{r}
#| label: scratch
#| include: false

top_bottom_16 |> 
  group_by(group) |> 
  summarise(
    sum_gametes = sum(est_fecund_n),
    gametes_80perc = round(sum_gametes * 0.8, 0),
    drew_est = round(sum(est_pre_hardened_egg_mass_g / avg_egg_mass_g, 0)),
    drew_est_80perc = round(drew_est * 0.8)
  )


dipac25_bkd_trim$total_thiamine_mass <- dipac25_bkd_trim$total_egg_mass_g * dipac25_bkd_trim$nmolT_egg


summary(top_bottom_16$total_thiamine )

ggplot(data = dipac25_bkd_trim, aes(x = deficient_conc, y = total_thiamine_mass)) +
  geom_violin(aes(fill = deficient_conc)) +
  geom_jitter() +
  scale_fill_discrete(type = my_palette)

tidy(wilcox.test(dipac25_bkd_trim[["total_thiamine_mass"]] ~ dipac25_bkd_trim$deficient_conc, data = dipac25_bkd_trim))


```

```{r}
#| label: flexmix
#| include: false

# A. Split the data into your pre-defined groups
replete_data <- dipac25_trim %>% filter(deficient_conc == "replete")
deficient_data <- dipac25_trim %>% filter(deficient_conc == "deficient")

# B. Fit a separate linear model (lm) to each group
model_replete <- lm(nmolT_egg ~ `mid-eye-fork-length`, data = replete_data)
model_deficient <- lm(nmolT_egg ~ `mid-eye-fork-length`, data = deficient_data)

# C. Calculate the combined log-likelihood and number of parameters
# Each lm() has 3 parameters: intercept, slope, and residual variance (sigma)
total_logLik <- logLik(model_replete) + logLik(model_deficient)
total_parameters <- (length(coef(model_replete)) + 1) + (length(coef(model_deficient)) + 1)

# D. Manually calculate the combined AIC using the formula: AIC = -2*logLik + 2*k
aic_predefined <- -2 * as.numeric(total_logLik) + 2 * total_parameters
print(paste("Pre-defined Groups AIC:", round(aic_predefined, 2)))


model_warm_start <- flexmix(nmolT_egg ~ `mid-eye-fork-length`,
                            data = dipac25_trim,
                            k = 2,
                            cluster = dipac25_trim$deficient_conc)

summary(model_warm_start)

parameters(model_warm_start)

table(dipac25_trim$deficient_conc, clusters(model_warm_start))

dipac25_flex <- dipac25_trim |> 
  mutate(cluster = as.factor(clusters(model_warm_start)))

ggplot(data = dipac25_flex, aes(x = `mid-eye-fork-length`, y = nmolT_egg,
                                color = cluster)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "r2", "p")),
               small.p = TRUE,
               coef.digits = 3,
               ) + 
  guides(color = "none") +
  scale_color_discrete(type = my_palette)

```

```{r}
#| label: mclust
#| include: false

mclust_model <- Mclust(dipac25_trim$nmolT_egg)

summary(mclust_model)
# Plot the density to see the component distributions
plot(mclust_model, what = "density", main = "Mixture Model for Total Egg Thiamine")

# Run the bootstrap LRT
# This can take a few minutes
lrt_test <- mclustBootstrapLRT(dipac25_trim$nmolT_egg, modelName = "E")

# Print the results
print(lrt_test)

```

```{r}
#| label: other-clustering
#| include: false

data_for_clustering <- dipac25_trim %>%
  select(where(is.numeric)) |> 
  select(-c(total_egg_mass_g, est_pre_hardened_egg_mass_g, est_fecund_n,
            `mid-eye-fork-length`, nmolT_g))

scaled_data <- scale(data_for_clustering)

# Hierarchical Clustering ------------------------------------------------------

dist_matrix <- dist(scaled_data, method = "euclidean")

hierarchical_model <- hclust(dist_matrix, method = "ward.D2")

plot(hierarchical_model, cex = 0.6, main = "Hierarchical Clustering Dendrogram")
rect.hclust(hierarchical_model, k = 2, border = "red") # Draw a box around 2 clusters

# Cut the tree to get 2 clusters
hierarchical_clusters <- cutree(hierarchical_model, k = 2)


# K-Means Clustering -----------------------------------------------------------
# Create the elbow plot
fviz_nbclust(scaled_data, kmeans, method = "wss")

set.seed(123) # for reproducibility

# Perform k-means clustering with k=2
kmeans_model <- kmeans(scaled_data, centers = 2, nstart = 25)

# Get the cluster assignments
kmeans_clusters <- kmeans_model$cluster


# Adding back in ---------------------------------------------------------------

dipac_other_clusters <- dipac25_trim |> 
  mutate(
    h_cluster = as.factor(hierarchical_clusters),
    k_cluster = as.factor(kmeans_clusters)
  )

```

```{r}
#| label: nmolTegg-vs-mefl-hclust
#| include: false

ggplot(data = dipac_other_clusters, aes(
  x = `mid-eye-fork-length`,
  y = nmolT_g,
  color = k_cluster)) +
  geom_point(size = 2) +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "r2", "p"),
               small.p = TRUE,
               coef.digits = 3) +
  #geom_text(aes(label = fish_id), vjust = "top", hjust = "right") +
  scale_color_discrete(type = my_palette) +
  theme(
    legend.position = "bottom"
  )

```

```{r}
#| label: groupings

dipac25_bkd_trim$nmolT_g

# Prepare the data for plotting
plot_data <- dipac25_bkd_trim %>%
  # Sort the values
  arrange(nmolT_g) %>%
  # Add an index for the x-axis and a grouping variable for the pairs
  mutate(
    index = row_number(),
    pair_group = (row_number() - 1) %/% 2
  )

# Create a summary data frame for the boxes
box_data <- plot_data %>%
  group_by(pair_group) %>%
  summarise(
    xmin = min(index) - 0.5,
    xmax = max(index) + 0.5,
    ymin = min(nmolT_g),
    ymax = max(nmolT_g),
    .groups = 'drop'
  )

# Create the plot
ggplot() +
  # Add the boxes first, so they are in the background
  geom_rect(
    data = box_data,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
    fill = "lightblue",
    alpha = 0.3,
    color = "grey50",
    linetype = "dashed"
  ) +
  # Add the points
  geom_point(
    data = plot_data,
    aes(x = index, y = nmolT_g),
    size = 2
  ) +
  # Add labels and a title
  labs(
    x = "Rank",
    y = "nmolT_g"
  ) +
  # Use a clean theme
  theme_bw()

write_csv(dipac25_bkd_trim, file = here("output/dipac_25_bkd_trim.csv"))

```

```{r}
#| label: alevin-init-size


alevin_init_sample_data_url <- "https://docs.google.com/spreadsheets/d/1USWhDAUBjClmPTshOR3Z_fBXyUgtNOcQHYwL3UTpEFE/edit?gid=1983306965#gid=1983306965"
alevin_init_sample_sheet <- "alevin-hatch-sampling"

alevin_init_sample_data <- read_sheet(alevin_init_sample_data_url,
                                      sheet = alevin_init_sample_sheet)
?pivot_longer

alevin_init_samp_long <- alevin_init_sample_data |> 
  pivot_longer(
    cols = matches("[A-Za-z]_Fish[0-9]+"),
    names_to = c(".value", "fish"),
    names_sep = "_"
  ) |> 
  filter(
    group != "duplicate"
  ) |> 
  mutate(
    group = factor(group, levels = c("16_lowest", "middle", "16_highest"))
  ) |> 
  mutate(
    id = factor(id)
  )

alevin_init_samp_means <- alevin_init_samp_long |> 
  group_by(id, group) |> 
  summarise(
    mean_mass_g = mean(g),
    sd_mass_g = sd(g),
    mean_length_mm = mean(mm),
    sd_length_mm = sd(mm)
  )

ggplot(data = alevin_init_samp_long, aes(y = g, x = fct_reorder(id, nmolT_g))) +
  geom_violin() +
  geom_jitter(aes(color = nmolT_g)) +
  scale_color_continuous(palette = "viridis") +
  facet_wrap(~group,
             scales = "free_x",
             ncol = 3)

ggplot(data = alevin_init_samp_long, aes(y = mm, x = fct_reorder(id, nmolT_g))) +
  geom_violin() +
  geom_jitter(aes(color = nmolT_g)) +
  scale_color_continuous(palette = "viridis") +
  facet_wrap(~group,
             scales = "free_x",
             ncol = 3)

ggplot(data = alevin_init_samp_means, aes(x = factor(group), y = mean_mass_g)) +
  geom_violin() +
  geom_jitter(data = alevin_init_samp_means,
              aes(x = factor(group), y = mean_mass_g,
                  color = id)) 

ggplot(data = test) +
  geom_violin(aes(x = factor(group), y = mm))

str(alevin_init_sample_data)

highest16 <- alevin_init_samp_long |> 
  filter(
    group == "16_highest"
  )

ggplot(highest16, aes(x = g, y = id)) +
  geom_density_ridges(
    aes(
      point_color = id,
      point_fill = id
    ),
    jittered_points = TRUE
  )

ggplot(alevin_init_samp_long) +
  geom_histogram(aes(x = g), bins = 15, fill = "pink") +
  geom_vline(xintercept = mean(alevin_init_samp_long$g)) +
  geom_vline(xintercept = mean(alevin_init_samp_long$g) + sd(alevin_init_samp_long$g), color = "red") +
geom_vline(xintercept = mean(alevin_init_samp_long$g) - sd(alevin_init_samp_long$g), color = "red")

mean <- mean(alevin_init_samp_long$g)
sd <- sd(alevin_init_samp_long$g)

countA <- alevin_init_samp_long |> 
  summarise(
    count_1sd = sum(g > (mean-(2*sd)) & g < (mean+(2*sd))),
    allcount = n()
  )

547/580

test <- rnorm(1000, mean = mean, sd = sd)

hist(test)

```

```{r}
#| label: lmm

alevin1_model <- lmer(g ~ nmolT_g + (1+nmolT_g|id), data = alevin_init_samp_long)

summary(alevin1_model)
```
