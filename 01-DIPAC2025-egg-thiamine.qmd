---
title: "Chinook Egg Thiamine, Macaulay 2025"
author: "Drew Porter"
date-modified: today
format: html
fig-width: 7
fig-height: 5
fig-dpi: 300
lightbox: true
editor: source
toc: true
toc-depth: 4
code-fold: true
output-file: "output"
editor_options: 
  chunk_output_type: console
---

## Introduction

This report is an analysis of Chinook salmon egg thiamine. Eggs were collected
from returning Chinook salmon at DIPAC's Macauley Hatchery in Juneau, AK on
2025-08-15.

For this analysis, individuals with eggs containing less than 5 nmol thiamine
per gram are considered to be "thiamine deficient", this is the consensus literature
value for deficient eggs. I am also interested in looking at thiamine on a per egg basis,
I've classified individuals with less than 1 nmol thiamine per egg as deficient, 
this is not an established criteria.

### Glossary of Variables

`fish_id`
: A unique identifier for each fish

`mid-eye-fork-length`
: The length in millimeters for each fish, taken from the middle of the eye 
to the fork in the caudal fin.

`avg_egg_mass_g`
: The average mass of an egg for each fish, measured in grams. Determined by 
dividing the total mass of eggs by the number of eggs measured for thiamine analysis.

`total_egg_mass_g`
: The total mass of eggs, in grams, for each fish, measured at DIPAC after 
fertilization and water hardening.

`est_pre_hardened_egg_mass_g`
: The estimated total mass of eggs, in grams, for each fish. Calculated by reducing
the total egg mass by 23%, which is the estimated increase in salmon egg weight
after water hardening, fertilization is not expected to significantly increase
egg weight (Fleming and Ng, 1987). I was using this to estimate fecundity
before Arthur sent estimated egg counts, I am using his counts now.

`est_fecund_n`
: The total estimated fecundity, representing the total number of eggs produced 
by each female. Provided by Arthur Hamlett, DIPAC. 

`nmolT_g`
: Nanomoles of thiamine per gram of egg.

`nmolT_egg`
: Nanomoles of thiamine per egg.


## Analysis

```{r}
#| label: setup
#| output: false

# Load libraries
library(tidyverse)
library(patchwork)
library(knitr)
library(ggpmisc)
library(here)
library(stringr) 
library(ggridges)
library(scales)
library(broom)
library(gt)

# ggplot theme set
theme_set(theme_bw())

# color palette
my_palette <- c("#1F77B4FF", "#FF7F0EFF", "#2CA02CFF", "#D62728FF", "#9467BDFF",
                "#8C564BFF", "#E377C2FF", "#7F7F7FFF", "#BCBD22FF", "#17BECFFF")


options(
  ggplot2.discrete.colour = list(scale_color_manual(values = my_palette)),
  ggplot2.discrete.fill = list(scale_fill_manual(values = my_palette))
)

```

```{r}
#| label: load-data
#| output: false

dipac25 <- read_rds(here("data/processed/dipac_females.rds"))

dipac25_trim <- dipac25 |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, total_egg_mass_g,
         est_pre_hardened_egg_mass_g, est_fecund_n, nmolT_g, deficient_conc, 
         nmolT_egg, deficient_totalT)

# These fish tested positive for BKD and cannot be included in the study
bkd_fish <- c("f13", "f34")

dipac25_bkd_trim <- dipac25_trim |> 
  filter(!(fish_id %in% bkd_fish))

names(dipac25_trim)

```
### Histograms

```{r}
#| label: histogram-bin-widths

# Define a function for calculating histogram bin widths Freedman-Diaconis rule
# Bin Width = 2 * IQR / n^(1/3)

fg_bin_width <- function(IQR, n) {
  2 * IQR / n^(1/3)
}

# Calculate bin widths
bin_width_mefl <- fg_bin_width(IQR(dipac25_bkd_trim$`mid-eye-fork-length`), 
                                   length(dipac25_bkd_trim$`mid-eye-fork-length`))

bin_width_avg_egg_mass <- fg_bin_width(IQR(dipac25_bkd_trim$avg_egg_mass_g), 
                                   length(dipac25_bkd_trim$avg_egg_mass_g))

bin_width_est_fecund <- fg_bin_width(IQR(dipac25_bkd_trim$est_fecund_n), 
                                   length(dipac25_bkd_trim$est_fecund_n))

bin_width_nmolT_g <- fg_bin_width(IQR(dipac25_bkd_trim$nmolT_g), 
                                   length(dipac25_bkd_trim$nmolT_g))

bin_width_nmolT_egg <- fg_bin_width(IQR(dipac25_bkd_trim$nmolT_egg), 
                                   length(dipac25_bkd_trim$nmolT_egg))
```

```{r}
#| label: build-histograms

histo_mefl <- ggplot(data = dipac25_bkd_trim, aes(x = `mid-eye-fork-length`)) +
  geom_histogram(binwidth = bin_width_mefl, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_avg_egg_mass <- ggplot(data = dipac25_bkd_trim, aes(x = avg_egg_mass_g)) +
  geom_histogram(binwidth = bin_width_avg_egg_mass, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_est_fecund <- ggplot(data = dipac25_bkd_trim, aes(x = est_fecund_n)) +
  geom_histogram(binwidth = bin_width_est_fecund, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_nmolT_g <- ggplot(data = dipac25_bkd_trim, aes(x = nmolT_g)) +
  geom_histogram(binwidth = bin_width_nmolT_g, fill = "#2CA02CFF", color = "black") +
  geom_rug()

histo_nmolT_egg <- ggplot(data = dipac25_bkd_trim, aes(x = nmolT_egg)) +
  geom_histogram(binwidth = bin_width_nmolT_egg, fill = "#2CA02CFF", color = "black") +
  geom_rug()
```

```{r}
#| label: plot-histograms
#| fig-cap: "Histograms for various fish and fish egg variables."

histo_patchwork <- histo_mefl + histo_avg_egg_mass + histo_est_fecund +
  histo_nmolT_g + histo_nmolT_egg + plot_layout(axes = "collect")

histo_patchwork
```
Everything is looking pretty normally distributed.

### Summary Statistics

```{r}
#| label: summary-stats-table

long_dipac25_bkd_trim <- dipac25_bkd_trim |>
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )

summary_table <- long_dipac25_bkd_trim |> 
  group_by(variable_name) |> 
  summarise(
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  )

summary_table |>
  kable(
    caption = "Summary Statistics for Fish and Egg Variables",
    col.names = c("Variable", "Mean", "Std. Dev.", "Min", "Max", "Median"),
    digits = 2
  )

```

### Exploring Egg Thiamine per Gram

#### Quartiles

```{r}
#| label: egg-thia-conc-quartiles

quantile(dipac25_bkd_trim$nmolT_g, probs = seq(0, 1, 0.25), na.rm = FALSE)

```

More than 25% of individuals eggs are deficient on a concentration basis.

#### % Deficient

```{r}

#| label: egg-thia-conc-count

dipac25_bkd_trim |> 
  summarise(
    n = n(),
    deficient = sum(deficient_conc),
    deficient_perc = (deficient / n) * 100
  )  |> 
  kable(
    caption = "Egg Thiamine Concentration",
    col.names = c("Individuals", "Number Deficient", "%Deficient"),
    digits = 2
  )

```
Of 58 fish, 16 are deficient (28%), what would it look like if we group the 16 
lowest concentration fish for a deficient group, and the 16 highest concentration
fish for a replete group?

## Grouping Ideas

### Lowest 16, Highest 16

In this grouping, we would select all the thiamine deficient (<5 nmol T/g) fish
for the low group, and the 16 fish with the highest egg thiamine concentrations
for the high group.

#### Density Plots

```{r}
#| label: subset-low-high-group

bottom_16 <- dipac25_bkd_trim |> 
  arrange(desc(nmolT_g)) |> 
  slice_tail(n = 16)

top_16 <- dipac25_bkd_trim |> 
  arrange(desc(nmolT_g)) |> 
  slice_head(n = 16)

top_bottom_16 <- rbind(bottom_16, top_16) |> 
  mutate(group = factor(if_else(nmolT_g > 5.0, "replete", "deficient")))

```

```{r}
#| label: low-high-density-dist
#| message: false

density_low_high_mefl <- ggplot(top_bottom_16, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_avg_egg_mass <- ggplot(top_bottom_16, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_est_fecund <- ggplot(top_bottom_16, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_nmolT_g <- ggplot(top_bottom_16, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_low_high_nmolT_egg <- ggplot(top_bottom_16, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: low-high-combined-density-dist
#| message: false

patchwork_low_high_densities <- density_low_high_mefl +
  density_low_high_avg_egg_mass +
  density_low_high_est_fecund +
  density_low_high_nmolT_g +
  density_low_high_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_low_high_densities
```

#### Summary Stats

```{r}
#| label: low-high-summary-stats
#| message: false

long_top_bottom_16 <- top_bottom_16 |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
    pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )

low_high_summary_table <- long_top_bottom_16 |> 
  group_by(variable_name, group) |> 
  summarise(
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for Lowest/Highest 16 Egg T. Concs",
    col.names = c("Variable", "Group" ," Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

low_high_summary_table

```

```{r}
#| label: low-high-gamete-est
#| output: false

deficient_gametes_top_bot_16 <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

replete_gametes_top_bot_16 <- top_bottom_16 |> 
  filter(group == "replete") |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females
bot_16_females <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  pull(fish_id)

formatted_deficient_id_list <- combine_words(bot_16_females)

# Get replete females
top_16_females <- top_bottom_16 |> 
  filter(group == "replete") |> 
  pull(fish_id)

formatted_replete_id_list <- combine_words(top_16_females)

# Calculate fish in each group and proportional gametes
top_bottom_16_total_n <- length(top_bottom_16$fish_id)

top_bot_16_deficient_n <- top_bottom_16 |> 
  filter(group == "deficient") |> 
  nrow()

top_bot_16_replete_n <- top_bottom_16_total_n - top_bot_16_deficient_n 

# Gametes
## Even Split

top_bot_16_even_split_gametes <- 90000 / 2 

top_bot_16_even_split_gametes_per_fish_deficient <-
  round(top_bot_16_even_split_gametes / top_bot_16_deficient_n, 0)

top_bot_16_even_split_gametes_per_fish_replete <-
  round(top_bot_16_even_split_gametes / top_bot_16_replete_n, 0)

### Is it even possible to get that many gametes from the deficient group?
top_bot_16_even_split_gametes_per_fish_deficient <= bottom_16$est_fecund_n

# 1 fish comes up short, which fish?
top_bot_16_short_deficient_fish <- bottom_16 |> 
  filter(top_bot_16_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_top_bot_16_short_deficient_fish  <- combine_words(
  top_bot_16_short_deficient_fish$fish_id)

fmt_top_bot_16_short_deficient_fish_gametes <- combine_words(comma(round(
  top_bot_16_short_deficient_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
top_bot_16_even_split_gametes_per_fish_replete <= top_16$est_fecund_n

# 1 fish comes up short, which fish?
top_bot_16_short_replete_fish <- top_16 |> 
  filter(top_bot_16_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_top_bot_16_short_replete_fish  <- combine_words(
  top_bot_16_short_replete_fish$fish_id)

fmt_top_bot_16_short_replete_fish_gametes <- combine_words(comma(round(
  top_bot_16_short_replete_fish$est_fecund_n, 0)))
```

This group would contain `{r} top_bot_16_deficient_n` fish in the deficient group and `{r} top_bot_16_replete_n` fish in the replete group. If gametes were split evenly per group and per fish that would be `{r} comma(90000/2)` gametes per group and `{r} comma(top_bot_16_even_split_gametes_per_fish_deficient)` gametes per fish.

Of the deficient fish, 
`{r} fmt_top_bot_16_short_deficient_fish`
comes up short with
`{r} fmt_top_bot_16_short_deficient_fish_gametes`
estimated gametes.

Of the replete fish,
`{r} fmt_top_bot_16_short_replete_fish`
comes up short with
`{r} fmt_top_bot_16_short_replete_fish_gametes`
estimated gametes.

The deficient females for this grouping are `{r} formatted_deficient_id_list`.

The replete females for this grouping are `{r} formatted_replete_id_list`.

#### Statistical Tests

```{r}
#| label: top-bot-16-parametric-tests
#| message: false

# T-test assumptions:
## 1.Independence of Observations --- Yes
## 2. Normality - shapiro.test()
## 3. Continuous data --- Yes
## 4. Random sampling --- Yes
## 5. Homogeneity of variance - var.test()

variables_to_test_parametric <- names(top_bottom_16[c(2,3,6,7,9)])

run_parametric_tests <- function(data, var_name) {
  
  
  var_res <- tidy(
    var.test(data[[var_name]] ~ data$group, data = data)
    )
  
  shapiro_replete_res <- tidy(
    shapiro.test(data[[var_name]][data$group == "replete"])
    )
  
  shapiro_deficient_res <- tidy(
    shapiro.test(data[[var_name]][data$group == "deficient"])
    )
  
  t_test_res <- tidy(
    t.test(data[[var_name]] ~ data$group, data = data, var.equal = TRUE)
  )
  
  tibble(
    Variable = var_name,
    `Shapiro p (replete)` = shapiro_replete_res$p.value,
    `Shapiro p (deficient)` = shapiro_deficient_res$p.value,
    `Var test p` = var_res$p.value,
    `t-statistic` = case_when(
      `Shapiro p (replete)` < 0.05 |
        `Shapiro p (deficient)` < 0.05 |
        `Var test p` < 0.05 ~ NA,
      TRUE ~ t_test_res$statistic
    ),
    `t-test p` = case_when(
      `Shapiro p (replete)` < 0.05 |
        `Shapiro p (deficient)` < 0.05 |
        `Var test p` < 0.05 ~ NA,
      TRUE ~ t_test_res$p.value
      )    
    )  
  
}

parametric_list_results <- map(
  variables_to_test_parametric, ~run_parametric_tests(top_bottom_16, .x)
  ) 
parametric_test_results <- list_rbind(parametric_list_results)

parametric_table <- parametric_test_results |> 
  gt() |> 
  tab_header(
    title = "Parametric Statistical Tests",
    subtitle = "Top/Bottom 16 Fish"
  ) |> 
  tab_spanner(
    label = md("Shapiro-Wilk Normality Test"),
    columns = c(`Shapiro p (replete)`, `Shapiro p (deficient)`)
  ) |> 
  tab_spanner(
    label = "F Test",
    columns = `Var test p`
  ) |> 
  tab_spanner(
    label = "Student's t-Test",
    columns = c(`t-statistic`, `t-test p`)
  ) |> 
  cols_label(
    `Shapiro p (replete)` = md("*p*~replete~"),
    `Shapiro p (deficient)` = md("*p*~deficient~"),
    `Var test p`= md("*p*"),
    `t-test p` = md("*p*")
  ) |> 
  tab_style(
    style = list(
      cell_text(color = "red")
    ),
    locations = list(
      cells_body(
      columns = `Shapiro p (replete)`,
      rows = `Shapiro p (replete)` < 0.05 
    ),
    cells_body(
      columns = `Shapiro p (deficient)`,
      rows = `Shapiro p (deficient)` < 0.05 
    ),
    cells_body(
      columns = `Var test p`,
      rows = `Var test p` < 0.05 
    )
    )
  ) |>
  fmt_number(
    columns = everything(),
    decimals = 3
  ) |> 
  sub_values(
    columns = contains("p"),
    fn = \(x) x < .001, replacement = "<0.001"
  )
  
parametric_table

```

```{r}
#| label: top-bot-16-non-parametric-tests
#| message: false

 # Mann-Whitney U Test Assumptions:
 # 1. All the observations from both groups are independent of each other,
 # 2. The responses are at least ordinal (i.e., one can at least say, of any two
 #    observations, which is the greater),
 # 3. Under the null hypothesis H0, the distributions of both populations are
 #    identical.
 # 4. The alternative hypothesis H1 is that the distributions are not identical.

variables_to_test_non_parametric <- names(top_bottom_16[c(7,9)])

run_non_parametric_tests <- function(data, var_name) {
  
  wilcox_res <- tidy(
    wilcox.test(data[[var_name]] ~ data$group, data = data)
    )
  
  tibble(
    Variable = var_name,
    `Mann-Whitney U p` = wilcox_res$p.value,
    `W statistic` = wilcox_res$statistic
    )  
  
}

non_parametric_list_results <- map(
  variables_to_test_non_parametric, ~run_non_parametric_tests(top_bottom_16, .x)
  ) 
non_parametric_test_results <- list_rbind(non_parametric_list_results)

non_parametric_table <- non_parametric_test_results |> 
  gt() |> 
  tab_header(
    title = "Non-Parametric Statistical Tests",
    subtitle = "Top/Bottom 16 Fish"
  ) |> 
  tab_spanner(
    label = md("Mann-Whitney U"),
    columns = c(`Mann-Whitney U p`, `W statistic`)
  ) |> 
  cols_label(
    `Mann-Whitney U p` = md("*p*"),
    `W statistic` = "W"
  ) |> 
    fmt_number(
    columns = everything(),
    decimals = 1
  ) |> 
  sub_values(
    columns = `Mann-Whitney U p`,
    fn = \(x) x < .001, replacement = "<0.001"
  )

non_parametric_table

```

### 50/50 split

In this grouping, we would keep all `{r} length(dipac25_bkd_trim$fish_id)` fish 
in the study and divide the low and high groups down the middle of egg thiamine concentrations (`{r} round(median(dipac25_bkd_trim$nmolT_g), 2)` nmol T/g).

#### Density Plots

```{r}
#| label: fifty-fifty-grouping

fifty_fifty <- dipac25_bkd_trim |> 
  mutate(group = factor(if_else(nmolT_g >= median(nmolT_g), "high", "low"),
                        levels = c("low", "high")))
```

```{r}
#| label: fifty-fifty-density-dist
#| message: false

density_fifty_fifty_mefl <- ggplot(fifty_fifty, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_avg_egg_mass <- ggplot(fifty_fifty, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_est_fecund <- ggplot(fifty_fifty, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_nmolT_g <- ggplot(fifty_fifty, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_fifty_fifty_nmolT_egg <- ggplot(fifty_fifty, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: fifty-fifty-combined-density-dist
#| message: false

patchwork_fifty_fifty_densities <- density_fifty_fifty_mefl +
  density_fifty_fifty_avg_egg_mass +
  density_fifty_fifty_est_fecund +
  density_fifty_fifty_nmolT_g +
  density_fifty_fifty_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_fifty_fifty_densities
```

#### Summary Stats

```{r}
#| label: fifty-fifty-summary-stats
#| message: false

fifty_fifty_long <- fifty_fifty |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )    
  
fifty_fifty_summary_table <- fifty_fifty_long |> 
  group_by(variable_name, group) |> 
  summarise(
    n = n(),
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for 50/50 Split Grouping",
    col.names = c("Variable", "Group", "N", " Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

fifty_fifty_summary_table

```

```{r}
#| label: fifty-fifty-gamete-est
#| output: false

total_gametes_fifty_fifty <- scales::comma(sum(fifty_fifty$est_fecund_n))

fifty_fifty_low <- fifty_fifty |> 
  filter(group == "low")

fifty_fifty_low_deficient_gametes <- fifty_fifty |> 
  filter(group == "low" & deficient_conc) |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

fifty_fifty_low_replete_gametes <- fifty_fifty |> 
  filter(group == "low" & !deficient_conc) |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

fifty_fifty_high_replete_gametes <- fifty_fifty |> 
  filter(group == "high" & !deficient_conc) |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females low group
fifty_fifty_low_deficient <- fifty_fifty |> 
  filter(group == "low" & deficient_conc)

fifty_fifty_low_deficient_females <- fifty_fifty_low_deficient |> 
  pull(fish_id)

fmt_fifty_fifty_low_deficient_ids <- combine_words(fifty_fifty_low_deficient_females)

# Get replete females low group
fifty_fifty_low_replete <- fifty_fifty |> 
  filter(group == "low" & !deficient_conc)

fifty_fifty_low_replete_females <- fifty_fifty_low_replete |> 
  pull(fish_id)

fmt_fifty_fifty_low_replete_ids <- combine_words(fifty_fifty_low_replete_females)

# Get replete females high group


fifty_fifty_high_replete <- fifty_fifty |> 
  filter(group == "high" & !deficient_conc) 

fifty_fifty_high_replete_females <- fifty_fifty_high_replete |> 
  pull(fish_id)

fmt_fifty_fifty_high_replete_ids <- combine_words(fifty_fifty_high_replete_females)

# Calculate fish in each group and proportional gametes
fifty_fifty_total_n <- length(fifty_fifty$fish_id)

fifty_fifty_low_n <- fifty_fifty |> 
  filter(group == "low") |> 
  nrow()

fifty_fifty_high_n <- fifty_fifty_total_n - fifty_fifty_low_n

# Gametes
## Even Split

fifty_fifty_even_split_gametes <- 90000 / 2 

fifty_fifty_even_split_gametes_per_fish_low <-
  round(fifty_fifty_even_split_gametes / fifty_fifty_low_n, 0)

fifty_fifty_even_split_gametes_per_fish_high <- 
  round(fifty_fifty_even_split_gametes / fifty_fifty_high_n, 0)

### Is it even possible to get that many gametes from the deficient group?
fifty_fifty_even_split_gametes_per_fish_low <= fifty_fifty_low$est_fecund_n

# 1 fish comes up short, which fish?
fifty_fifty_short_low_fish <- fifty_fifty_low |> 
  filter(fifty_fifty_even_split_gametes_per_fish_low > est_fecund_n)

fmt_fifty_fifty_short_low_fish <- combine_words(
  fifty_fifty_short_low_fish$fish_id)

fmt_fifty_fifty_short_low_fish_gametes <- combine_words(comma(round(
  fifty_fifty_short_low_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
fifty_fifty_even_split_gametes_per_fish_high <= fifty_fifty_high_replete$est_fecund_n

# All replete fish have enough gametes
```

This grouping would contain 
`{r} fifty_fifty_low_n` 
fish in the "low" group; of those fish
`{r} length(fifty_fifty_low_deficient_females)` 
would be considered "deficient" in egg thiamine concentration, 
`{r} length(fifty_fifty_low_replete_females)`
would be considered "replete". The "high" group would contain 
`{r} fifty_fifty_high_n` 
"replete" fish.

Our 90,000 fish allowance would include `{r} comma(90000/2)` "low" and
`{r} comma(90000/2)` "high" gametes if we split the groups evenly, this works out
to `{r} comma(90000 / length(fifty_fifty$fish_id))` gametes
per fish.

Of the low group, fish 
`{r} fmt_fifty_fifty_short_low_fish`
does not have enough estimated gametes 
(`{r} fmt_fifty_fifty_short_low_fish_gametes`).
All of the high group fish have enough estimated gametes.

The deficient females in the "low" group for this grouping are 
`{r} fmt_fifty_fifty_low_deficient_ids`. The replete females in the "low"
group for this grouping are `{r} fmt_fifty_fifty_low_replete_ids`.

The replete females in the "high" group for this grouping are 
`{r} fmt_fifty_fifty_high_replete_ids`.

### 5 nmol T/g split

In this grouping, we would keep all `{r} length(dipac25_bkd_trim$fish_id)` fish 
in the study and divide the deficient and replete groups at the 5 nmol T/g benchmark. This would result in an uneven split.

#### Density Plots

```{r}
#| label: five-nmol-grouping

five_nmol <- dipac25_bkd_trim |> 
  mutate(group = factor(if_else(nmolT_g >= 5, "replete", "deficient"),
                        levels = c("deficient", "replete")))
```

```{r}
#| label: five-nmol-density-dist
#| message: false

density_five_nmol_mefl <- ggplot(five_nmol, 
                                aes(x = `mid-eye-fork-length`,
                                    y = group,
                                    fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_avg_egg_mass <- ggplot(five_nmol, aes(x = avg_egg_mass_g,
                                                   y = group,
                                                   fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_est_fecund <- ggplot(five_nmol, 
                                      aes(
                                        x = est_fecund_n,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_nmolT_g <- ggplot(five_nmol, 
                                      aes(
                                        x = nmolT_g,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)

density_five_nmol_nmolT_egg <- ggplot(five_nmol, 
                                      aes(
                                        x = nmolT_egg,
                                        y = group,
                                        fill = group)) +
  geom_density_ridges(
    jittered_points = TRUE,
    position = "raincloud",
    alpha = 0.75
  ) +
  guides(fill = "none") +
  scale_fill_manual(values = my_palette)
```

```{r}
#| label: five-nmol-combined-density-dist
#| message: false

patchwork_five_nmol_densities <- density_five_nmol_mefl +
  density_five_nmol_avg_egg_mass +
  density_five_nmol_est_fecund +
  density_five_nmol_nmolT_g +
  density_five_nmol_nmolT_egg +
  plot_layout(axes = "collect")
  
patchwork_five_nmol_densities
```

#### Summary Stats

```{r}
#| label: five-nmol-summary-stats
#| message: false

five_nmol_long <- five_nmol |> 
  select(fish_id, `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g,
         nmolT_egg, group) |> 
  pivot_longer(
    cols = c(
      `mid-eye-fork-length`, avg_egg_mass_g, est_fecund_n, nmolT_g, nmolT_egg
      ),
    names_to = "variable_name",
    values_to = "value"
  )    
  
five_nmol_summary_table <- five_nmol_long |> 
  group_by(variable_name, group) |> 
  summarise(
    n = n(),
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    min = round(min(value, na.rm = TRUE), 2),
    max = round(max(value, na.rm = TRUE), 2),
    median = round(median(value, na.rm = TRUE), 2)
  ) |>
  kable(
    caption = "Summary Statistics for 5 nmol T/g Split Grouping",
    col.names = c("Variable", "Group", "N", " Mean", "Std. Dev.", "Min", "Max",
                  "Median"),
    digits = 2
  )

five_nmol_summary_table

```

```{r}
#| label: five-nmol-gamete-est
#| output: false
#| message: false

total_gametes_five_nmol <- round(sum(five_nmol$est_fecund_n), 0)

five_nmol_deficient_gametes <- five_nmol |> 
  filter(group == "deficient" & deficient_conc) |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

five_nmol_replete_gametes <- five_nmol |> 
  filter(group == "replete" & !deficient_conc) |> 
  summarise(total = sum(est_fecund_n)) |> 
  pull(total) |> 
  comma()

# Get deficent females 
five_nmol_deficient <- five_nmol |> 
  filter(group == "deficient" & deficient_conc)

five_nmol_deficient_females <- five_nmol_deficient |> 
  pull(fish_id)

fmt_five_nmol_deficient_ids <- combine_words(five_nmol_deficient_females)

# Get replete females group
five_nmol_replete <- five_nmol |> 
  filter(group == "replete" & !deficient_conc) 

five_nmol_replete_females <- five_nmol_replete |> 
  pull(fish_id)

fmt_five_nmol_replete_ids <- combine_words(five_nmol_replete_females)

# Calculate fish in each group and proportional gametes
five_nmol_total_n <- length(five_nmol$fish_id)

five_nmol_deficient_n <- length(five_nmol_deficient$fish_id)

five_nmol_replete_n <- length(five_nmol_replete$fish_id)

five_nmol_deficient_prop <- five_nmol_deficient_n / five_nmol_total_n

five_nmol_replete_prop <- five_nmol_replete_n / five_nmol_total_n

# Gametes
## Even Split

five_nmol_even_split_gametes <- 90000 / 2 

five_nmol_even_split_gametes_per_fish_deficient <-
  round(five_nmol_even_split_gametes / five_nmol_deficient_n, 0)

five_nmol_even_split_gametes_per_fish_replete <- 
  round(five_nmol_even_split_gametes / five_nmol_replete_n, 0)

### Is it even possible to get that many gametes from the deficient group?
five_nmol_even_split_gametes_per_fish_deficient <= five_nmol_deficient$est_fecund_n

# 1 fish comes up short, which fish?
five_nmol_short_deficient_fish <- five_nmol_deficient |> 
  filter(five_nmol_even_split_gametes_per_fish_deficient > est_fecund_n)

fmt_five_nmol_short_deficient_fish <- combine_words(
  five_nmol_short_deficient_fish$fish_id)

fmt_five_nmol_short_deficient_fish_gametes <- combine_words(comma(round(
  five_nmol_short_deficient_fish$est_fecund_n, 0)))

# Is it possible for replete fish?
five_nmol_even_split_gametes_per_fish_replete <= five_nmol_replete$est_fecund_n

## Proportional split

five_nmol_prop_split_gametes_deficient <- 
  round(five_nmol_deficient_prop * 90000, 0) 

five_nmol_prop_split_gametes_per_fish_deficient <- 
  round(five_nmol_prop_split_gametes_deficient / five_nmol_deficient_n, 0) 

five_nmol_prop_split_gametes_replete <- 
  round(five_nmol_replete_prop * 90000, 0) 

five_nmol_prop_split_gametes_per_fish_replete <- 
  round(five_nmol_prop_split_gametes_replete / five_nmol_replete_n, 0) 

# Is this possible for deficient fish?

five_nmol_prop_split_gametes_per_fish_deficient <= five_nmol_deficient$est_fecund_n

# 1 fish come up short, which fish?
five_nmol_short_prop_deficient_fish <- five_nmol_deficient |> 
  filter(five_nmol_prop_split_gametes_per_fish_deficient > est_fecund_n)

fmt_five_nmol_short_prop_deficient_fish <- combine_words(
  five_nmol_short_prop_deficient_fish$fish_id)

fmt_five_nmol_short_prop_deficient_fish_gametes <- combine_words(comma(round(
  five_nmol_short_prop_deficient_fish$est_fecund_n, 0)))

# Possible for replete group? 
five_nmol_prop_split_gametes_per_fish_replete <= 
  five_nmol_replete$est_fecund_n

# All replete fish have enough gametes
```

This grouping would contain `{r} five_nmol_deficient_n` fish in the "deficient" group and `{r} five_nmol_replete_n` fish in the "replete" group. Proportionately
that is `{r} round(five_nmol_deficient_prop * 100, 1)`% deficient fish and
`{r} round(five_nmol_replete_prop * 100, 1)`% replete fish.

If we wanted to have an even number of gametes per group (i.e., 
`{r} comma(90000/2)` gametes), it would require 
`{r} comma(five_nmol_even_split_gametes_per_fish_deficient)` gametes per
deficient fish and
`{r} comma(five_nmol_even_split_gametes_per_fish_replete)` gametes per
replete fish. One deficient fish (`{r} fmt_five_nmol_short_deficient_fish`)
is short of this many estimated gametes 
(`{r} fmt_five_nmol_short_deficient_fish_gametes`). 
This shortage could be covered by other deficient fish. All
of the replete fish have enough gametes for this split.

If we wanted to have a proportional number of gametes for each group (i.e.,
`{r} comma(five_nmol_prop_split_gametes_deficient)` gametes for the deficient group and `{r} comma(five_nmol_prop_split_gametes_replete)` gametes for the replete group), it would require 
`{r} comma(five_nmol_prop_split_gametes_per_fish_deficient)` 
per fish for each group. Again, fish
`{r} fmt_five_nmol_short_prop_deficient_fish` from the deficient group comes up short (only `{r} fmt_five_nmol_short_prop_deficient_fish_gametes` estimated gametes). This shortage could be covered by other deficient females. For the replete group, all fish have enough estimated gametes.

The deficient females in this grouping are: 
`{r} fmt_five_nmol_deficient_ids`. 

The replete females in this grouping are:
`{r} fmt_five_nmol_replete_ids`.

## Andrew Creek Stock Thiamine Concentrations

![Andrew Creek stock Chinook salmon thiamine concentrations. The dashed red line indicates 5 nmol T/g, the threshold for deficient eggs.](output/plots/andrew_creek_thiamine_conc_yearly.png)

## Linear Models
 
```{r}
#| label: total-egg-mass-vs-conc

ggplot(data = dipac25_bkd_trim, aes(x = nmolT_g, y = total_egg_mass_g)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "r2", "p")))


```

